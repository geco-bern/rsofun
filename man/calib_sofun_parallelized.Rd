% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calib_sofun_parallelized.R
\name{calib_sofun_parallelized}
\alias{calib_sofun_parallelized}
\title{Calibrates SOFUN model parameters (for parallelized applications)}
\usage{
calib_sofun_parallelized(
  drivers,
  obs,
  settings,
  optim_out = TRUE,
  logpath = file.path(tempdir(), paste0("out_calib_", "my_calibration_name",
    ".rds.log.txt")),
  ...
)
}
\arguments{
\item{drivers}{A data frame with driver data. See \code{\link{pmodel_drivers}}
for a description of the data structure. Additional columns can optionally be 
provided to \code{drivers} to control e.g. the processing within a 
personalized cost function.}

\item{obs}{A data frame containing observational data used for model
calibration. See \code{\link{pmodel_validation}} for a description of the data
structure. Additional columns can optionally be provided to \code{obs} to 
control e.g. the processing within a personalized cost function.}

\item{settings}{A list containing model calibration settings. 
See the 'P-model usage' vignette for more information and examples.
\describe{
 \item{\code{method}}{A string indicating the optimization method, either \code{'GenSA'}
 or \code{'BayesianTools'}.}
 \item{\code{par}}{A list of model parameters. For each parameter, an initial value 
 and lower and upper bounds should be provided. The calibratable parameters
 include model parameters 'kphio', 'kphio_par_a', 'kphio_par_b', 'soilm_thetastar',
 'soilm_betao', 'beta_costunitratio', 'rd_to_vcmax', 'tau_acclim', 'kc_jmax'
 and 'rootzone_whc' , and (if
 doing Bayesian calibration) error parameters
 for each target variable, named for example 'err_gpp'. This list must match
 the input parameters of the calibration metric and the parameters should be
 given in the order above.}
 \item{\code{metric}}{A cost function. See the 'Cost functions for parameter
 calibration' vignette for examples.}
 \item{\code{control}}{A list of arguments passed on to the optimization function.
 If \code{method = 'GenSA'}, see \link[GenSA]{GenSA}. If \code{method = 'BayesianTools'}
 the list should include at least \code{settings} and \code{sampler}, see
 \link[BayesianTools:runMCMC]{BayesianTools::runMCMC}.}
}}

\item{optim_out}{A logical indicating whether the function returns and stores 
the raw output of the optimization functions (defaults to TRUE).}

\item{logpath}{A path where a log-file is created and progress logged for 
parallel sampling, defaults to a temporary directory. The path is stored in 
the output object as simulation `name` and `logpath`. (Note that this argument 
is only used when parallelized sampling is requested.)}

\item{...}{Optional arguments, simply passed on to the cost function.}
}
\value{
A named list containing the calibrated parameter vector `par`,
the output object from the optimization `mod`, and additional identifier 
outputs `name`, `logpath`, and `walltime`. For more details on the `mod`
output and how to evaluate it, see \link[BayesianTools:runMCMC]{runMCMC} (also
\href{https://florianhartig.github.io/BayesianTools/articles/BayesianTools.html}{this post})
and \link[GenSA]{GenSA}. If parallel also a logfile is created at `logpath`.
}
\description{
Runs the requested model calibration, stores to data-folder and returns results
}
\details{
This is the main function that handles the 
calibration of SOFUN model parameters.
}
\examples{
# Define priors of model parameters that will be calibrated
params_to_estimate <- list(
  kphio           = list(lower = 0.02, upper = 0.15, init = 0.05),
  err_gpp         = list(lower = 0.01, upper = 3, init = 0.8),
  err_bigD13C     = list(lower = 0.5, upper = 4.0, init = 2.0)
)
# Fix model parameters that won't be calibrated
params_fix       <- list(
  kphio_par_a        = 0,
  kphio_par_b        = 25,
  soilm_thetastar    = 0.6*240,
  soilm_betao        = 0.01,
  beta_unitcostratio = 146,
  rd_to_vcmax        = 0.014,
  tau_acclim         = 30,
  kc_jmax            = 0.41
)
# Define calibration settings
settings <- list(
  method  = "BayesianTools",
  par     = params_to_estimate,
  metric  = rsofun::cost_likelihood_pmodel_bigD13C_vj_gpp,
  control = list(
    sampler = "DEzs",
    settings = list(
      nrChains = 1,
      burnin = 0,
      iterations = 50     # kept artificially low
    ),
    n_chains_independent   = 1, # 2,
    n_parallel_independent = 1  # 2, this can be parallelized
  )
)
# Run the calibration for GPP and D13C data
calib_output <- rsofun::calib_sofun_parallelized(
  drivers = rsofun::pmodel_drivers    |>
    dplyr::filter(sitename \%in\% c("FR-Pue","lon_+146.13_lat_-032.97")),
  obs     = rsofun::pmodel_validation |>
    dplyr::filter(sitename \%in\% c("FR-Pue","lon_+146.13_lat_-032.97")),
  settings = settings,
  # extra arguments for the cost function
  par_fixed = params_fix
)
calib_output$mod      # BayesianTools::mcmcSamplerList
calib_output$par      # Named vector
calib_output$walltime # Benchmarked time
calib_output$runtime  # unused
calib_output$name     # optionally used calibration name
calib_output$fpath    # path of rds output
}
