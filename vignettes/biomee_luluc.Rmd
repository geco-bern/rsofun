---
title: "BiomeE LULUC"
author: "Mayeul Marcadella"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BiomeE LULUC}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(rsofun)
library(dplyr)
library(ggplot2)
```

## Overview

BiomeE is a dynamic vegetation demography simulation engine capable of predicting the evolution of a *vegetation tile* characterized by static parameters (species, soil parameters, initial conditions, etc)
when subject to environmental forcing. To learn more, please refer to `vignette("BiomeE usage")`. Starting from v5.1, BiomeE is capable of simulating land use and land-use change (LULUC) by evolving multiple vegetation tiles, each with different vegetation types and/or different land-use practices. This section presents an overview of the concepts and methods.

### Fractional tiles

Conceptually, BiomeE simulates a grid cell of area 1 (arbitrary unit) divided in several *land units* (LU). The *fraction* of the cell occupied by each LU varies with time driven by *land-use change* forcing.
Each LU is implemented as a fractional tile, that is a vegetation tile associated with a scalar (`fraction`) keeping track of the area occupied by the LU.

### LU transitions

A square transition matrix `T` encodes the exogenous yearly land-use change: `T_{i,j}` is the fraction of LU `i` transitioning to LU `j` on January 1st (start of the year).
Such a LUC transition is modelled as a clear-cut of the fraction `T_{i,j}` in LU `i` and transfer of the corresponding area to LU `j`, along with the soil organic pools, water, and belowground biomass converted to litter.
The aboveground biomass is sent to 3 product pools with e-folding times of 0, 2 and 20 years respectively.

Each transition found in the matrix is evaluated in turn and the transfer of matter to each destination LU is kept track of throughout the update process and finally added to the LUs.
This gross transition heuristic provides better accuracy compared to a strategy where net transitions are considered (thereby transitions from `i` to and from `j` cancels each others out).

### Clear-cut and harvest

The diagonal of the transition matrix contains self transitions `T_{i,i}`, where a fraction of LU `i` is clear-cut, but without any transfer of area, water or soil organic matter.
The aboveground biomass as exported to the product pools, while the belowground biomass is converted to litter and remains in place.
In effect, this models the forestry practice of clear-cutting as well as crop harvest.

### Other land management practices

LUs can furthermore be tailored to model broad categories of land management:

- which species grow in the LU (or none in the case of an urban area),
- fixed addition of nitrogen (N fertilization)
- extra soil turnover rate (ex: tillage)
- direct oxidation of litter (crop and grass harvest)

### Output

The output contains the cohort and tile annual diagnostics for each LU, as well as for a virtual tile aggregating each LU.

An example of output is available in the package:
```{r eval = FALSE}
library(rsofun)

# Output obtained from simulating biomee_p_model_luluc_drivers
biomee_p_model_luluc_output
```


## Getting started

This section demonstrates how to simulate LULUC with BiomeE.

### Setup

The package contains an example of driver from the Swiss CH-LAE fluxnet site, using environmental data for the year 2009,
where 40 % of an initial primary forest is clear-cut and convert to a secondary (yet unmanaged) forest.

```{r eval = FALSE}
library(rsofun)

biomee_p_model_luluc_drivers
```

The default setting is to simulate 1 year of transient data after 250 years of spin-up.
Let us increase the transient period to 300 years:

```{r eval = TRUE}
df_drivers <- biomee_p_model_luluc_drivers
df_drivers$params_siml[[1]]$nyeartrend <- 300
```

Let us have a glance at the LU settings:
```{r eval = TRUE}
df_drivers$init_lu[[1]]
```

There are two LU defined:
- `primary`: with an initial fraction of 1
- `secondary`: with an initial fraction of 0

The spin-up will use these initial fractions without applying any land-use change.
Note that the names of the LUs are arbitrary: BiomeE do not infer anything from these names.

Let us now turn our attention to the transition matrix:

```{r eval = TRUE}
df_drivers$luc_forcing[[1]]
```

It is a 3-dimensional matrix. The first two dimensions represent a square matrix of size 2x2 (we have defined 2 LUs), and the third dimension represents the years, starting from the first transient year.
In this case we have only one year, meaning that there is only one LU change at the beginning of year 1, then the simulation proceeds without further LU change for the remaining of the simulation.

### Simulation

We can now run the simulation:

```{r eval = TRUE, results = 'hide', warning = FALSE}
out_sim_1 <- runread_biomee_f(df_drivers)
```

Next, we define some convenience functions for displaying plots:

```{r eval = TRUE, results = 'hide'}
library(gridExtra)
library(purrr)

plot1 <- function(lu_name, variable, out, y_limit=NA, yr_start=1) {
  tile <- out[[lu_name]][[1]]
  if(lu_name != 'aggregated')
          tile <- tile$output_annual_tile
  if (variable != 'lu_fraction') {
    res <- tile %>%
          ggplot() +
          geom_line(aes(x = year,
                        y = get(variable) * lu_fraction)) +
          xlim(yr_start, NA) +
          ylim(0, y_limit) +
          theme_classic() +
          labs(x = "Year", y = paste(variable, "(", lu_name, ")"))
  } else {
    res <- tile %>%
            ggplot() +
            geom_line(aes(x = year,
                          y = get(variable))) +
            xlim(yr_start, NA) +
            ylim(0, y_limit) +
            theme_classic() +
            labs(x = "Year", y = paste(variable, "(", lu_name, ")"))
  }

  return(res)
}

plot_variable <- function(variable, out, yr_start=1) {
  agg <- out[['aggregated']][[1]]
  y_limit <- max(agg[variable] * agg$lu_fraction) * 1.01

  # We remove sitename and aggregated
  tile_names <- names(out)[3:length(names(out))]

  names <- c(tile_names, 'aggregated')

  names |> lmap(\(x) plot1(x, variable, out, y_limit, yr_start))
}

plot_variables <- function(variables, out, yr_start=1) {

  plots <- variables |> lmap(\(x) plot_variable(x, out, yr_start))
  grid.arrange(grobs=plots, nrow = length(variables))
}
```

We finally plot, for each LU and the aggregated tile, GPP, the litter carbon (`fastSOM`), and the LU fraction:

```{r eval = TRUE, results = 'hide', warning = FALSE, fig.width=7, fig.height=7}
plot_variables(c('GPP', 'fastSOM', 'lu_fraction'), out_sim_1)
```

Looking at GPP (first row), the primary forest (left column) spins-up to steady state until year 250 which marks the end of the spin-up period and start of the transient period. A sharp drop corresponds to the loss of 40% of the area (see third row). The pattern corresponding to the steady-state continues but scaled down. We observe a similar behavior for the litter (second row).

The secondary forest (second column) has no data until year 250 as the initial fraction was 0.
GPP increases until reaching steady-state as expected. Since the same species is used in both LU, the GPP stabilizes at the same level (proportionally to the LU fraction).
The litter follows a different pattern: at year 250, it inherits a lot of litter from the primary LU. The amount of litter drops sharply due to natural processes and not replenishment because of the low initial productivity of the tile. As productivity increases (see GPP), the amount of litter finally increases again and stabilizes at a level proportional to its fraction.

The third column displays the aggregated tile, summing each tile relative to its fraction.
GPP shows a sharp drop then recovery. Litter shows a sharp increase (due to below ground biomass being converted to litter) followed by a drop (mineralization) then recovery.
Finally, the fraction, remains constant throughout the simulation.

To conclude this demonstration, we can plot the product pools:

```{r eval = TRUE, results = 'hide', fig.width=7, fig.height=3}
p1 <- out_sim_1$aggregated[[1]] %>%
        ggplot() +
        geom_line(aes(x = year, y = prod_pool_1_C)) +
        theme_classic() +
        labs(x = "Year", y = paste("Prod. pools C (2 years)"))

p2 <- out_sim_1$aggregated[[1]] %>%
        ggplot() +
        geom_line(aes(x = year, y = prod_pool_2_C)) +
        theme_classic() +
        labs(x = "Year", y = paste("Prod. pools C (20 years)"))

grid.arrange(p1, p2, nrow = 1)
```

As expected, the product pools get filled with the wood harvested and decay with their respective e-folding time.

## Wood harvest and urbanism

We will now implement a more complex scenario.
In addition to the one time transition from a primary to a secondary forest:

- each year, one thousand of the primary forest will transition to an urban tile,
- every 40 years, one quarter of the secondary forest will be clear-cut (wood harvest), but the area will remain in the same tile.

Furthermore, the species planted in the secondary forest is another one than that of the primary forest.

Let us configure these requirements:

```{r eval = TRUE}
df_drivers <- biomee_p_model_luluc_drivers

# We extend the transient period to 300 years
n_trans <- 300
df_drivers$params_siml[[1]]$nyeartrend <- n_trans

# We configure two cohorts with two different species (see 'init_cohort_species'): one for tile 1 and one for tile 2 (see 'lu_index').
# Tile 3 is a urban tile: it does not accept any cohort.
df_drivers$init_cohort[[1]] <- tibble(
        init_cohort_species = c(2, 3),      # species
        init_cohort_nindivs = rep(0.05, 2), # initial individual density, individual/m2 ! 1 indiv/m2 = 10.000 indiv/ha
        init_cohort_bl      = rep(0.0,  2), # initial biomass of leaves, kg C/individual
        init_cohort_br      = rep(0.0,  2), # initial biomass of fine roots, kg C/individual
        init_cohort_bsw     = rep(0.05, 2), # initial biomass of sapwood, kg C/individual
        init_cohort_bHW     = rep(0.0,  2), # initial biomass of heartwood, kg C/tree
        init_cohort_seedC   = rep(0.0,  2), # initial biomass of seeds, kg C/individual
        init_cohort_nsc     = rep(0.05, 2), # initial non-structural biomass
        lu_index            = c(1, 2)       # index land use (LU) containing this cohort. 0 (default) means any vegetated tile will contain a copy.
)

lu_defs <- tibble(
        name      = c('primary', 'secondary', 'urban'),
        fraction  = c(1.0, 0.0, 0.0),
        # We defined which LU can accept vegetation cohorts
        # Technically, this was not necessary since no 'lu_index' above points to the third LU
        # (but it is a good idea to enforce this anyways)
        vegetated = c(TRUE, TRUE, FALSE)
        # Equivalently, presets could have been used instead:
        #preset = c('unmanaged', 'unmanaged', 'urban')
)
n_lu <- length(lu_defs$name)

# Initial transition
# 3 LUs, so each year land-use change is represented by 3x3 transitions.
# The first 3 numbers are the transitions from each LU to the first LU,
# the following three numbers are the transitions from each LU to the second LU, and so on.
initial_transition <- c(0, 0, 0, 0.4, 0, 0, 0, 0, 0)

# Harvest pattern: clear-cut one fourth (0.4/4 = 0.1) of the tile every 40 years.
# Clear-cuts are represented by self-transitions of LU 2.
harvest_pattern <- c(
        rep(rep(0, 9), 39), # null pattern
        c(0, 0, 0, 0, 0.1, 0, 0, 0, 0)
)
# We repeat the harvest pattern enough times
harvest_transitions <- rep(harvest_pattern, 10)

# We define a transition from primary to urban repeated every year
urban_transition <- rep(c(0, 0, 0, 0, 0, 0, 0.0006, 0, 0), n_trans)

# We add all the transition matrix
transitions_matrix <- build_luc_matrix(list(initial_transition, harvest_transitions, urban_transition), n_lu, n_trans)

# We set the LU definitions and transition forcing in the driver:
df_drivers$init_lu[[1]] <- lu_defs
df_drivers$luc_forcing[[1]]  <- transitions_matrix
```

We can now run the simulation and display some of the outputs:

```{r eval = TRUE, results = 'hide', warning = FALSE, fig.width=7, fig.height=7}
out_sim_2 <- runread_biomee_f(df_drivers)
plot_variables(c('GPP', 'fastSOM', 'lu_fraction'), out_sim_2)
```

As expected GPP is null for the urban tile (non vegetation). Note that the litter for this tile is not zero, but too small to be seen at this scale.

As before, we can also look at the product pools:

```{r eval = TRUE, results = 'hide', fig.width=7, fig.height=3}
p1 <- out_sim_2$aggregated[[1]] %>%
        ggplot() +
        geom_line(aes(x = year, y = prod_pool_1_C)) +
        theme_classic() +
        labs(x = "Year", y = paste("Prod. pools C (2 years)"))

p2 <- out_sim_2$aggregated[[1]] %>%
        ggplot() +
        geom_line(aes(x = year, y = prod_pool_2_C)) +
        theme_classic() +
        labs(x = "Year", y = paste("Prod. pools C (20 years)"))

grid.arrange(p1, p2, nrow = 1)
```

## Crop rotation and land management

We now model crop rotation and management practices.
A primary forest is initially clear-cut to cultivate crop. Then every two years one third of the land is left unmanaged (fallow.)

Let us configure these requirements:

```{r eval = TRUE}
df_drivers <- biomee_p_model_luluc_drivers

# We extend the transient period to 300 years
n_trans <- 300
df_drivers$params_siml[[1]]$nyeartrend <- n_trans

# We configure three cohorts
df_drivers$init_cohort[[1]] <- tibble(
        init_cohort_species = c(2, 1, 2),      # species
        init_cohort_nindivs = rep(0.05, 3), # initial individual density, individual/m2 ! 1 indiv/m2 = 10.000 indiv/ha
        init_cohort_bl      = rep(0.0,  3), # initial biomass of leaves, kg C/individual
        init_cohort_br      = rep(0.0,  3), # initial biomass of fine roots, kg C/individual
        init_cohort_bsw     = rep(0.05, 3), # initial biomass of sapwood, kg C/individual
        init_cohort_bHW     = rep(0.0,  3), # initial biomass of heartwood, kg C/tree
        init_cohort_seedC   = rep(0.0,  3), # initial biomass of seeds, kg C/individual
        init_cohort_nsc     = rep(0.05, 3), # initial non-structural biomass
        lu_index            = c(1, 2, 3)    # index land use (LU) containing this cohort. 0 (default) means any vegetated tile will contain a copy.
)

lu_defs <- tibble(
        name      = c('primary', 'crop', 'fallow'),
        fraction  = c(1.0, 0.0, 0.0),
        # Here we use presets to easily configure some parameters for the cropland
        # ('extra_N_input', 'extra_turnover_rate', 'oxidized_litter_fraction')
        # preset 'unmanaged' sets all these parameters to 0
        preset = c('unmanaged', 'cropland', 'unmanaged')
)
n_lu <- length(lu_defs$name)

# Initial transition
# 3 LUs, so each year land-use change is represented by 3x3 transitions.
# The first 3 numbers are the transitions from each LU to the first LU,
# the following three numbers are the transitions from each LU to the second LU, and so on.
initial_transition <- c(0, 0, 0, 0.66, 0, 0, 0.34, 0, 0)

# Fallow pattern:
fallow_pattern <- c(
        c(0, 0, 0, 0, 0, 0.33, 0, 0.33, 0),
        rep(0, 9) # null pattern
)
# We repeat the harvest pattern enough times
fallow_transitions <- rep(harvest_pattern, 150)

# We add all the transition matrix
transitions_matrix <- build_luc_matrix(list(initial_transition, fallow_transitions), n_lu, n_trans)

# We set the LU definitions and transition forcing in the driver:
df_drivers$init_lu[[1]] <- lu_defs
df_drivers$luc_forcing[[1]]  <- transitions_matrix
```

We can now run the simulation as before.

Notes:

- Crop harvesting is already included in land management (via `oxidized_litter_fraction`), so it does not require a self-transition as for wood harvesting.
- This example uses a dummy C4 grass setup (species 1) and would not yield meaningful results.

## LUH2 integration

BiomeE can work directly with LUH2 v2 data (https://luh.umd.edu/data.shtml).

### Automatic configuration

Below is an example of minimal configuration:

```{r eval = FALSE}
df_drivers <- biomee_p_model_drivers
# Disable daily diagnostics (optional)
df_drivers$params_siml[[1]]$daily_diagnostics <- FALSE

# Simulate for 10 years after the spinup period. By default the same number of years are extracted from LUH2 dtaa.
df_drivers$params_siml[[1]]$nyeartrend <- 10
# In order to extract a custom number of years, set the following:
# df_drivers$luh2[[1]]$n <- ...
# By default the extraction start at the first year in the ncdf files. To extract from a custom index:
# df_drivers$luh2[[1]]$start <- ...

# Setting the path to LUH2 files. These may be different on your computer.
df_drivers$luh2[[1]]$cst_file   <- 'path/to/staticData_quarterdeg.nc'
df_drivers$luh2[[1]]$state_file <- 'path/to/states.nc'
df_drivers$luh2[[1]]$trans_file <- 'path/to/transitions.nc'

# Indicate whether to use simplified states.
df_drivers$luh2[[1]]$simplified <- TRUE
# By default all the states defined in LUH2 v2 are used (12 states)
# In the simplified mode, only 5 states are used:
# prim     <- primf + primn
# secd     <- secdf + secdn
# urban    <- urban
# cropland <- cxxxx
# pasture  <- pastr + range
```

Then run the simulation as before.

Notes:

- Extracting data from LUH2 ncdf files may take some time.
- The cell that is extracted from LUH2 data is the closest cell from the coordinates provided in site_info.
- If no `init_lu` is present in the configuration, a default configuration is automatically generated. If you wish to provide your own, make sure to use the right state names.
- When using LUH2 data, `luc_forcing` must not be provided in the driver.

### Manual configuration

The automatic configuration presented above is convenient, but parsing LUH2 data is slow, so it might be worth parsing once and
storing the transitions for later reuse. This can be done using `parse_luh2`, then manually building the `init_lu` configuration:

```{r eval = FALSE}
# We start from the example driver
df_drivers_luh2 <- biomee_p_model_luluc_drivers

# The LUH2 dataset used contains 85 years (2015-2100)
df_drivers_luh2$params_siml[[1]]$nyeartrend <- 85
df_drivers_luh2$params_siml[[1]]$daily_diagnostics <- FALSE

# Files downloaded from https://luh.umd.edu/data.shtml)
# These path may be different on your machine.
cst_file   <- '~/RPC2.6_SSP1/staticData_quarterdeg.nc'
state_file <- '~/RPC2.6_SSP1/multiple-states_input4MIPs_landState_ScenarioMIP_UofMD-IMAGE-ssp126-2-1-f_gn_2015-2100.nc'
trans_file <- '~/RPC2.6_SSP1/multiple-transitions_input4MIPs_landState_ScenarioMIP_UofMD-IMAGE-ssp126-2-1-f_gn_2015-2100.nc'

# Parse LUH2 data
parsed_luh2 <- parse_luh2(cst_file, state_file, trans_file,
                          df_drivers_luh2$site_info[[1]]$lon, df_drivers_luh2$site_info[[1]]$lat,
                          start=1, n=df_drivers_luh2$params_siml[[1]]$nyeartrend, # We parse the whole dataset
                          simplified=TRUE # simplified mode: 5 states only
)

# Create the init_lu config
init_lu <- tibble(
        # Keep these two lines
        name      = names(parsed_luh2$states_init),
        fraction  = parsed_luh2$states_init,
        # The following line should be taylored to your application:
        preset    = c(rep('unmanaged', 2), 'urban', 'cropland', 'pasture')
        # In addition more fine-graind parameters could be set ('extra_N_input', 'extra_turnover_rate', 'oxidized_litter_fraction')
)

# Set init_lu and luc_forcing in driver
df_drivers_luh2$init_lu[[1]] <- init_lu
df_drivers_luh2$luc_forcing[[1]] <- parsed_luh2$luc_matrix

# Note: in this example, we do not set df_drivers$init_cohort for brevity, but it should be done as well as demonstrated in the previous sections.
```

```{r load luluc driver, include = FALSE}
# Since the LUH2 data is not stored in this repo, we load the driver from disk
#saveRDS(df_drivers_luh2, "files/biomee_luluc.Rmd__biomee_p_model_luluc_driver.RDS")
df_drivers_luh2 <- readRDS("files/biomee_luluc.Rmd__biomee_p_model_luluc_driver.RDS")
```

We can now simulate and display the plots:

```{r eval = TRUE, results = 'hide', warning = FALSE, fig.width=7, fig.height=7}
out_sim_3 <- runread_biomee_f(df_drivers_luh2)
plot_variables(c('GPP', 'fastSOM', 'lu_fraction'), out_sim_3, df_drivers_luh2$params_siml[[1]]$spinupyears)
```